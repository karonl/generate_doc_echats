'use strict';

var column = require('./column.cjs');
var utils = require('./utils.cjs');

const defaultStyle = {
    columnWidth: 150,
    borderColor: '#e8e8e8',
    textAlign: 'left',
    color: 'rgba(0,0,0,0.85)',
    fontSize: '14px',
    fontFamily: 'sans-serif',
    headerBgColor: 'rgba(0,0,0,0.02)',
    padding: 16,
    background: null,
    lineHeight: 22,
};
class Table2canvas {
    constructor({ canvas, padding, columns = [], dataSource = [], style, bgColor, text, textStyle, width, height }) {
        /**table title  style */
        this.textStyle = { textAlign: 'center', lineHeight: 22 };
        this.tableWidth = 0;
        this.tableHeight = 55;
        this.headHeight = 55;
        this.left = 10;
        this.top = 10;
        this.right = 10;
        this.bottom = 10;
        this.trHeights = [];
        this.canvas = canvas;
        this.dataSource = dataSource || [];
        const _style = Object.assign(Object.assign({}, defaultStyle), style);
        this.style = _style;
        this.bgColor = bgColor !== null && bgColor !== void 0 ? bgColor : 'transparent';
        this.text = text;
        this.width = width || 'auto';
        this.height = height || 'auto';
        this.padding = utils.handlePadding(padding);
        this.textStyle = Object.assign(Object.assign(Object.assign({}, this.textStyle), { color: _style.color, fontSize: _style.fontSize, fontFamily: _style.fontFamily }), textStyle);
        const cellPadding = utils.handlePadding(_style.padding);
        this.cellPadding = cellPadding;
        const rowHeight = _style.lineHeight + cellPadding[0] + cellPadding[2];
        this.rowHeight = rowHeight;
        if (text) {
            this.padding[0] += this.textStyle.lineHeight;
        }
        this.left = this.padding[3];
        this.right = this.padding[1];
        this.top = this.padding[0];
        this.bottom = this.padding[2];
        this.ctx = canvas.getContext('2d');
        this.columns = column.genColumns(columns, {
            width: _style.columnWidth,
            height: rowHeight,
            borderColor: _style.borderColor,
            padding: cellPadding,
            fontSize: _style.fontSize,
            fontFamily: _style.fontFamily,
            bgColor: _style.headerBgColor,
            textAlign: _style.textAlign,
        });
        this.flatColumns = column.flatColumns(this.columns);
        this.render();
    }
    render() {
        this.resize();
        this.renderTh();
        const { dataSource, tableWidth, ctx, left, top, headHeight } = this;
        if (!dataSource.length && tableWidth) {
            this.renderNoData();
        }
        else {
            ctx.save();
            ctx.translate(left, top + headHeight);
            this.renderTr();
            ctx.restore();
        }
        this.renderTitle();
    }
    renderTh() {
        const { ctx, top, left } = this;
        let x = left;
        for (const item of this.columns) {
            ctx.save();
            ctx.translate(x, top);
            this.renderThItem(item);
            ctx.restore();
            x += item.width;
        }
    }
    renderThItem(item, x = 0, y = 0) {
        const { ctx } = this;
        const { borderColor, titleColor, textAlign, title, fontFamily, fontSize = '14px', bgColor, titleFontSize, titleFontWeight = 'bold' } = item.config;
        const { width, height, textWidth, baseConfig: { padding }, children } = item;
        ctx.save();
        ctx.strokeStyle = borderColor;
        ctx.fillStyle = bgColor;
        ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);
        ctx.stroke();
        ctx.restore();
        ctx.save();
        titleColor && (ctx.fillStyle = titleColor);
        ctx.textAlign = textAlign !== null && textAlign !== void 0 ? textAlign : 'left';
        ctx.font = `${titleFontWeight} ${titleFontSize !== null && titleFontSize !== void 0 ? titleFontSize : fontSize} ${fontFamily}`;
        const midY = y + 0.5 * height;
        if (textAlign === 'center' || (children === null || children === void 0 ? void 0 : children.length)) {
            ctx.textAlign = 'center';
            ctx.fillText(title, x + 0.5 * width, midY, textWidth);
        }
        else if (textAlign === 'right') {
            ctx.fillText(title, x + width - padding[1], midY, textWidth);
        }
        else {
            ctx.fillText(title, x + padding[3], midY, textWidth);
        }
        ctx.fill();
        ctx.restore();
        if (children === null || children === void 0 ? void 0 : children.length) {
            let _x = x + 0;
            let _y = y + height;
            for (const c of children) {
                this.renderThItem(c, _x, _y);
                _x += c.width;
            }
        }
    }
    renderNoData() {
        const { tableWidth, ctx, style, top, left, headHeight, rowHeight } = this;
        ctx.save();
        ctx.strokeStyle = style.borderColor;
        ctx.strokeRect(left, top + headHeight, tableWidth, rowHeight * 2);
        ctx.fillStyle = "#999";
        ctx.textAlign = 'center';
        ctx.fillText('Empty Data!', left + 0.5 * tableWidth, top + headHeight + rowHeight, tableWidth);
        ctx.restore();
    }
    renderTr() {
        const { dataSource, ctx } = this;
        for (let i = 0, l = dataSource.length; i < l; i++) {
            const trHeight = this.getTrHeight(dataSource[i], i);
            this.renderTrItem(dataSource[i], i);
            ctx.translate(0, trHeight);
        }
    }
    renderTrItem(row, i) {
        var _a, _b, _c, _d, _e;
        const { ctx, rowHeight, flatColumns, trHeights } = this;
        const trHeight = trHeights[i];
        let x = 0;
        const padding = (_a = flatColumns[0]) === null || _a === void 0 ? void 0 : _a.config.padding;
        for (const { config: item } of flatColumns) {
            const { render, dataIndex, textAlign, fontSize = '14px', fontFamily, borderColor, textOverflow } = item;
            let { textColor, textFontSize, textFontWeight, width } = item;
            let height = trHeight;
            let text = '';
            if (typeof render === 'string') {
                if (dataIndex) {
                    text = render.replace(/\{c\}/g, (_b = row[dataIndex]) !== null && _b !== void 0 ? _b : '');
                }
                else {
                    text = render;
                }
            }
            else if (typeof render === 'function') {
                const res = render(dataIndex ? ((_c = row[dataIndex]) !== null && _c !== void 0 ? _c : '') : '', row, i);
                if (res && typeof res === 'object') {
                    const { rowSpan = 1, colSpan = 1 } = res;
                    res.textColor && (textColor = res.textColor);
                    res.textFontSize && (textFontSize = res.textFontSize);
                    res.textFontWeight && (textFontWeight = res.textFontWeight);
                    text = (_d = res.text) !== null && _d !== void 0 ? _d : '';
                    width = width * colSpan;
                    height = utils.getRowSpanHeight(trHeights, i, rowSpan);
                }
                else {
                    text = res !== null && res !== void 0 ? res : '';
                }
            }
            else if (dataIndex) {
                text = (_e = row[dataIndex]) !== null && _e !== void 0 ? _e : '';
            }
            if (width && height) {
                ctx.save();
                ctx.strokeStyle = borderColor;
                ctx.strokeRect(x, 0, width, height);
                ctx.stroke();
                ctx.restore();
                if (text !== '') {
                    text += '';
                    ctx.save();
                    const lineHeight = rowHeight - padding[0] - padding[2];
                    const maxTextHeight = height - padding[0] - padding[2];
                    const textWidth = width - padding[3] - padding[1];
                    const textHeight = utils.getTextHeight(ctx, { text, lineHeight, width: textWidth });
                    ctx.translate(x + padding[3], padding[0] + (maxTextHeight - textHeight) / 2);
                    if (textOverflow === 'ellipsis') {
                        const fontsize = parseFloat(textFontSize !== null && textFontSize !== void 0 ? textFontSize : fontSize) || 14;
                        text = utils.getSubStr(text, textWidth, fontsize / 2);
                    }
                    ctx.textAlign = textAlign !== null && textAlign !== void 0 ? textAlign : 'left';
                    textColor && (ctx.fillStyle = textColor);
                    ctx.font = `${textFontWeight !== null && textFontWeight !== void 0 ? textFontWeight : ''} ${textFontSize !== null && textFontSize !== void 0 ? textFontSize : fontSize} ${fontFamily}`;
                    utils.fillTexts(ctx, { text: text, lineHeight, width: textWidth });
                    ctx.restore();
                }
            }
            x += item.width;
        }
    }
    renderTitle() {
        if (!this.text)
            return;
        const { ctx, left, top, right, tableWidth, textStyle, text } = this;
        const { fontSize, fontFamily, color, textAlign, lineHeight } = textStyle;
        ctx.save();
        ctx.translate(left, top);
        ctx.font = `bold ${fontSize} ${fontFamily}`;
        ctx.fillStyle = color || '#333';
        ctx.textAlign = textAlign || 'center';
        const midY = -lineHeight * 0.5;
        const width = this.canvas.width;
        if (ctx.textAlign === 'center') {
            ctx.fillText(text, 0.5 * width, midY, tableWidth);
        }
        else if (ctx.textAlign === 'right') {
            ctx.fillText(text, width - right, midY, tableWidth);
        }
        else {
            ctx.fillText(text, left, midY, tableWidth);
        }
        ctx.restore();
    }
    initCtxStatus() {
        const { ctx } = this;
        const { color, fontSize, fontFamily, textAlign } = this.style;
        ctx.font = `${fontSize} ${fontFamily}`;
        ctx.fillStyle = color;
        ctx.textAlign = textAlign;
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
    }
    resize() {
        const { ctx, canvas } = this;
        const maxThRowNum = Math.max(...this.flatColumns.map(v => v.deep));
        let width = 0;
        for (const item of this.columns) {
            width += item.width;
        }
        this.tableWidth = width;
        this.headHeight = maxThRowNum * this.rowHeight;
        // let height = length * this.rowHeight + this.headHeight;
        let height = this.getBodyHeight() + this.headHeight;
        this.tableHeight = height;
        const [top, right, bottom, left] = this.padding;
        width = width + left + right;
        height = height + top + bottom;
        let scale = 1;
        if (this.width === 'auto' && this.height !== 'auto') {
            scale = height / this.height;
        }
        else if (this.width !== 'auto' && this.height === 'auto') {
            scale = width / this.width;
        }
        else if (this.width !== 'auto' && this.height !== 'auto') {
            scale = Math.max(width / this.width, height / this.height);
        }
        scale = scale || 1;
        scale = 1 / scale;
        canvas.width = width * scale;
        canvas.height = height * scale;
        this.initCtxStatus();
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = this.bgColor;
        //canvas background color
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        //table background color
        if (this.style.background) {
            ctx.fillStyle = this.style.background;
            ctx.fillRect(top * scale, left * scale, this.tableWidth * scale, this.tableHeight * scale);
        }
        ctx.restore();
        ctx.scale(scale, scale);
    }
    getBodyHeight() {
        var _a;
        if (!((_a = this.dataSource) === null || _a === void 0 ? void 0 : _a.length)) {
            this.trHeights = [];
            return this.rowHeight * 2;
        }
        let totalHeight = 0;
        const { dataSource } = this;
        this.trHeights = [];
        for (let i = 0, l = dataSource.length; i < l; i++) {
            const trHeight = this.getTrHeight(dataSource[i], i);
            totalHeight += trHeight;
            this.trHeights.push(trHeight);
        }
        return totalHeight;
    }
    getTrHeight(row, i) {
        const { ctx, rowHeight, flatColumns, style, cellPadding: padding } = this;
        const { lineHeight } = style;
        return Math.max(...flatColumns.map(({ config: item }) => {
            var _a, _b, _c, _d;
            const { render, dataIndex, textOverflow } = item;
            const { fontSize = '14px', fontFamily } = item;
            if (textOverflow === 'ellipsis') {
                return rowHeight;
            }
            let { width, textFontSize, textFontWeight, } = item;
            let height = rowHeight;
            let text = '';
            let maxRowSpan = 1;
            if (typeof render === 'string') {
                if (dataIndex) {
                    text = render.replace(/\{c\}/g, (_a = row[dataIndex]) !== null && _a !== void 0 ? _a : '');
                }
                else {
                    text = render;
                }
            }
            else if (typeof render === 'function') {
                const res = render(dataIndex ? ((_b = row[dataIndex]) !== null && _b !== void 0 ? _b : '') : '', row, i);
                if (res && typeof res === 'object') {
                    const { rowSpan = 1, colSpan = 1 } = res;
                    res.textFontSize && (textFontSize = res.textFontSize);
                    res.textFontWeight && (textFontWeight = res.textFontWeight);
                    text = (_c = res.text) !== null && _c !== void 0 ? _c : '';
                    width = width * colSpan;
                    height = height * rowSpan;
                    maxRowSpan = rowSpan;
                }
                else {
                    text = res !== null && res !== void 0 ? res : '';
                }
            }
            else if (dataIndex) {
                text = (_d = row[dataIndex]) !== null && _d !== void 0 ? _d : '';
            }
            ctx.font = `${textFontWeight !== null && textFontWeight !== void 0 ? textFontWeight : ''} ${textFontSize !== null && textFontSize !== void 0 ? textFontSize : fontSize} ${fontFamily}`;
            const trHeight = utils.getTextHeight(ctx, { text: text + '', lineHeight: lineHeight || 22, width: width - padding[1] - padding[3] }) + padding[0] + padding[2];
            if (maxRowSpan === 1) {
                return trHeight;
            }
            else if (maxRowSpan <= 0) {
                return rowHeight;
            }
            else if (trHeight > height) {
                return trHeight - (maxRowSpan - 1) * rowHeight;
            }
            return trHeight;
        }));
    }
    appendData(dataSource) {
        if (dataSource.length) {
            this.dataSource = this.dataSource.concat(dataSource);
            this.render();
        }
    }
}

module.exports = Table2canvas;
